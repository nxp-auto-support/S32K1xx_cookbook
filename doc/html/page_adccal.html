<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NXP: Analog-to-Digital Converter Calibration (ADC)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="s32k1xx_cookbook_logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NXP
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">S32K1xx Series Cookbook</a></li>  </ul>
</div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Analog-to-Digital Converter Calibration (ADC) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Description </h2>
<p>There are three main sub-blocks in the S32K SAR ADC: the capacitive DAC, the comparator, and the SAR engine that controls the module.<br />
Of those blocks, the DAC, which is the heart of the SAR ADC, is most susceptible to variations that can cause linearity problems in the SAR.<br />
It is implemented with capacitors (CDAC) based on charge redistribution, where the capacitors are switched between Vin,<br />
the reference voltage VRH and VRL to set the appropriate output voltage.<br />
To overcome errors during internal switching events, the CDAC is represented on both inputs to the comparator to generate the error in both directions.<br />
The CDAC on the positive comparator input is used for sample&amp;hold (s/h CDAC).<br />
<br />
 </p><div class="image">
<img src="Diagram_ADC_Calibration_Module.png" alt="Diagram_ADC_Calibration_Module.png"/>
</div>
<p> <br />
</p>
<p>This CDAC architecture uses a self-calibration method, which is measuring the error of the MSB caps in the CDAC (CLPx registers) and from there calculating <br />
 a total gain error of the CDAC (Gain register). The ADC measurement then is influenced with those calibration results in two places. <br />
First, the raw ADC result gets compensated with the measured MSB cap errors CLPx by subtracting it from the raw value depending on which of the MSB bits are set.<br />
 Second, the Gain error, which was measured during the calibration phase influences the connected caps during the sample&amp;hold phase.<br />
<br />
</p><h2>Gain and Offset Error </h2>
<p><br />
 </p><div class="image">
<img src="Diagram_ADC_Calibration_Raw.png" alt="Diagram_ADC_Calibration_Raw.png"/>
</div>
<p> <br />
 </p><div class="image">
<img src="Diagram_ADC_Calibration_Final.png" alt="Diagram_ADC_Calibration_Final.png"/>
</div>
<p> <br />
Gain error is defined as the full-scale error minus the zero-scale offset error, which causes the actual transfer function to deviate from the ideal transfer function.<br />
The measured calibration values in the registers CLP0, CLP1, CLP2, CLP3 are used to correct the raw result. If bit 11 in the 15-bit raw result is set,<br />
 then the CLP0 value is subtracted from the raw value, if bit 12 in the 15-bit raw result is set, then the CLP1 value is subtracted from the raw value, etc.<br />
The Gain value has an impact on the sampling phase for Vin. Whenever the sample phase starts, the caps in the LSB cap bank are connected to Vin<br />
 depending on its corresponding bit value in the G register. The default value of the G register after reset is 0x7FF, it connects all lower caps C0 to C10<br />
 to Vin during the sample phase. The value 0x3FF would only connect C0 to C9 to Vin during sampling.<br />
<br />
 The offset error OFS is defined as the deviation of the actual ADC transfer function from the ideal straight line at the zero input voltage.<br />
 The offset error is also known as the zero-scale error, which indicates how well the actual ADC transfer function matches the ideal input at the zero point. <br />
The offset value is calculated by the self-calibration algorithm, the operation is done in 15bit notation, and a 15bit result is stored in <br />
the OFS register as two's-complement value.<br />
In S32K the built-in default offset value is 0xFFF8 representing -8.<br />
<br />
 <br />
</p><h2>Calibration Procedure </h2>
<p><br />
In order to calibrate the ADC correctly, the following has to be done:<br />
<br />
</p><ul>
<li>On startup, wait until the reference voltage (VREFH) has stabilized.<br />
</li>
<li>ADC has to be recalibrated after each system reset.<br />
</li>
<li>Calibrate only one ADC instance at a time. So, when calibrating instance ADC0, the<br />
 instances ADC1, ADC2, and so on, are required to be idle.<br />
</li>
<li>You must set ADCK (ADC clock) to a value less than or equal to half of the maximum specified frequency.<br />
</li>
<li>Before starting calibration, the calibration registers (CLPS, CLP3, CLP2, CLP1,<br />
 CLP0, CLPX, and CLP9) must be cleared by writing 0000_0000h into each of them.<br />
</li>
<li>Start ADC calibration by writing SC3[CAL] = 1, SC3[AVGE] = 1, and SC3[AVGS]= 11b.<br />
</li>
<li>Wait for calibration to finish. This will be indicated by conversion complete flag (SC1n[COCO] = 1).<br />
</li>
<li>Now you can run ADC conversions with high accuracy in your application. Please<br />
 make sure to reconfigure the ADCK clock speed and reconfigure AVGE and AVGS<br />
 to your desired settings. (Maximum clock speed and no use of hardware averaging ispossible.)<br />
<br />
 <h2>Design </h2>
</li>
</ul>
<p>ADC calibration is not included in this simple example. Hence the results can be lower than the specified<br />
accuracy. The steps to initialize the calibration mechanism are found in the Calibration function section of<br />
the ADC chapter of the reference manual. <br />
<br />
</p><ul>
<li>System clocks: Initialize SOSC for 8 MHz, sysclk for 80 MHz, RUN mode for 80 MHz<br />
</li>
<li>Initialize port pins:<br />
</li>
<li>Initialize ADC:<br />
<ul>
<li>Select SOSCDIV2_CLK for functional clock and enable it to module<br />
</li>
<li>Disable module and disable interrupt requests from module (reset default state)<br />
</li>
<li>Configure ADC for 12-bit conversions using SOSCDIV2_CLK, divided by 1<br />
</li>
<li>Configure sample time of 13 ADCK clock cycles (reset default value)<br />
</li>
<li>Select software trigger for conversions, no compare functions, no DMA and use default voltage<br />
 reference pins - external pins VREFH and VREFL. (reset default value)<br />
</li>
<li>Disable continuous conversions (so there is one conversion per software trigger), disable<br />
 hardware averaging, disable calibration sequence start up<br />
</li>
</ul>
</li>
<li>Initialize WDOG:<br />
<ul>
<li>Refresh window is [0.5s - 1s].<br />
</li>
</ul>
</li>
<li>Initialize LPUART1:<br />
<ul>
<li>Enable clock source of SOSC_DIV2_CLK.<br />
</li>
<li>Configure baud rate: 9600 baud, one stop bit, 8 bit characters.<br />
</li>
<li>No interrupts, DMA or match features enabled.<br />
</li>
<li>Configure LPUART1 control: Enable transmitter, receiver, no parity, 8 bit characters.<br />
</li>
</ul>
</li>
<li>Loop:<br />
<ul>
<li>Ask if the User wants to calibrate the ADC module.<br />
</li>
<li>Reboot the MCU to calibrate again if desired.<br />
</li>
<li>If No:<br />
<ul>
<li>Convert ADC channel data without calibration.<br />
</li>
</ul>
</li>
<li>If Yes:<br />
<ul>
<li>Ask if the User wants to set a specific gain.<br />
</li>
<li>Ask if the User wants to set a specific offset.<br />
</li>
<li>Convert ADC channel data with the specified calibration values.<br />
</li>
<li>Reboot the MCU to calibrate again if desired.<br />
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br />
</p><h2>Pins definitions: </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">S32K116  </th><th class="markdownTableHeadNone">S32K118  </th><th class="markdownTableHeadNone">S32K142  </th><th class="markdownTableHeadNone">S32K144  </th><th class="markdownTableHeadNone">S32K146  </th><th class="markdownTableHeadNone">S32K148   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">UART1 [Tx]  </td><td class="markdownTableBodyNone">PTB1  </td><td class="markdownTableBodyNone">PTB1  </td><td class="markdownTableBodyNone">PTC7  </td><td class="markdownTableBodyNone">PTC7  </td><td class="markdownTableBodyNone">PTC7  </td><td class="markdownTableBodyNone">PTC7   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">UART1 [Rx]  </td><td class="markdownTableBodyNone">PTB0  </td><td class="markdownTableBodyNone">PTB0  </td><td class="markdownTableBodyNone">PTC6  </td><td class="markdownTableBodyNone">PTC6  </td><td class="markdownTableBodyNone">PTC6  </td><td class="markdownTableBodyNone">PTC6   </td></tr>
</table>
<p><br />
</p><h2>ADC Channel connected to Potentiometer: </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Board  </th><th class="markdownTableHeadNone">Channel   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">S32K116  </td><td class="markdownTableBodyNone">AD3   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">S32K118  </td><td class="markdownTableBodyNone">AD2   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">S32K142  </td><td class="markdownTableBodyNone">AD12   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">S32K144  </td><td class="markdownTableBodyNone">AD12   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">S32K146  </td><td class="markdownTableBodyNone">AD12   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">S32K148  </td><td class="markdownTableBodyNone">AD28   </td></tr>
</table>
<p><br />
</p><h2>Driver Functions: </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Driver   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_a_d_c_8h.html#a4b4a2ddcb45df0c8497c47d4ed800e2a" title="ADC Initialization for SW trigger without calibration.">ADC_init</a>  </td><td class="markdownTableBodyNone">adc   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_a_d_c_8h.html#ac27380c28d20b6c927922551d67cd743" title="ADC Initialization for SW trigger with calibration.">ADC_calibration_init</a>  </td><td class="markdownTableBodyNone">adc   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_a_d_c_8h.html#af76221118c7f520fe574bd6845a07d90" title="Initiate ADC conversion in the desired channel.">ADC_channel_convert</a>  </td><td class="markdownTableBodyNone">adc   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_a_d_c_8h.html#ac1e8aec564becbe003bfca11292ebd0e" title="Check the conversion complete flag [COCO].">ADC_conversion_complete</a>  </td><td class="markdownTableBodyNone">adc   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_a_d_c_8h.html#ac3cde85577a5404fd5bc14cf3a06eb34" title="Read ADC channel and convert result to mV for 0-5 V range.">ADC_channel_read</a>  </td><td class="markdownTableBodyNone">adc   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_l_p_u_a_r_t_8h.html#a735e25c9d923840ffb8b3f25e90f54c6">LPUART1_init</a>  </td><td class="markdownTableBodyNone">LPUART   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_l_p_u_a_r_t_8h.html#afffea491e64bb00b6c8fd6bde67dff6e">LPUART1_transmit_char</a>  </td><td class="markdownTableBodyNone">LPUART   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_l_p_u_a_r_t_8h.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>  </td><td class="markdownTableBodyNone">LPUART   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_l_p_u_a_r_t_8h.html#a556289ca43dede22a5d0426adfeffa81">LPUART1_receive_char</a>  </td><td class="markdownTableBodyNone">LPUART   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_l_p_u_a_r_t_8h.html#a964c616e2505a648e4c42deba01d7ae0">LPUART1_receive_and_echo_char</a>  </td><td class="markdownTableBodyNone">LPUART   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_l_p_u_a_r_t_8h.html#a7203f5441ba24299d8565e7dd2d2ba46" title="Stores data from the LPUART1 Rx buffer until ENTER key is pressed.">LPUART1_receive_int</a>  </td><td class="markdownTableBodyNone">LPUART   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_l_p_u_a_r_t_8h.html#a2c21e01901e389a16d4a2f8eb9a0f282" title="Convert int data to char to be able to transmit it by UART. NOTE: This function can convert 5 digit v...">LPUART1_int_to_char</a>  </td><td class="markdownTableBodyNone">LPUART   </td></tr>
</table>
<p><br />
</p><h2>main.c </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Copyright (c) 2014 - 2016, Freescale Semiconductor, Inc.</span></div><div class="line"><span class="comment"> * Copyright (c) 2016 - 2018, NXP.</span></div><div class="line"><span class="comment"> * All rights reserved.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Redistribution and use in source and binary forms, with or without</span></div><div class="line"><span class="comment"> * modification, are permitted provided that the following conditions are met:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span></div><div class="line"><span class="comment"> *    this list of conditions and the following disclaimer.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span></div><div class="line"><span class="comment"> *    this list of conditions and the following disclaimer in the documentation</span></div><div class="line"><span class="comment"> *    and/or other materials provided with the distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 3. Neither the name of the copyright holder nor the names of its contributors</span></div><div class="line"><span class="comment"> *    may be used to endorse or promote products derived from this software</span></div><div class="line"><span class="comment"> *    without specific prior written permission.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * THIS SOFTWARE IS PROVIDED BY NXP &quot;AS IS&quot; AND ANY EXPRESSED OR</span></div><div class="line"><span class="comment"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span></div><div class="line"><span class="comment"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span></div><div class="line"><span class="comment"> * IN NO EVENT SHALL NXP OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,</span></div><div class="line"><span class="comment"> * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span></div><div class="line"><span class="comment"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span></div><div class="line"><span class="comment"> * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span></div><div class="line"><span class="comment"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span></div><div class="line"><span class="comment"> * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span></div><div class="line"><span class="comment"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</span></div><div class="line"><span class="comment"> * THE POSSIBILITY OF SUCH DAMAGE.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;device_registers.h&quot;</span>           <span class="comment">/* include peripheral declarations */</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="clocks__and__modes_8h.html">clocks_and_modes.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_a_d_c_8h.html">ADC.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_l_p_u_a_r_t_8h.html">LPUART.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_w_d_o_g_8h.html">WDOG.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define PTC6 (6)</span></div><div class="line"><span class="preprocessor">#define PTC7 (7)</span></div><div class="line"></div><div class="line">uint16_t <a class="code" href="main__adc__cal_8c.html#a1641e09b7d9068c3eefc78d79157047a">answer</a> = 0;</div><div class="line">uint16_t <a class="code" href="main__adc__cal_8c.html#a7c07aa50dffd011a3b181ea4ecb54f8e">gain</a> = 0;</div><div class="line">uint16_t <a class="code" href="main__adc__cal_8c.html#ac681806181c80437cfab37335f62ff39">offset</a> = 0;</div><div class="line">uint32_t <a class="code" href="main__adc__cal_8c.html#a80c5f48bb6d79b957d2eaaf1f03b34bb">adc_mV_result</a> = 0;</div><div class="line">uint8_t <a class="code" href="main__adc__cal_8c.html#a0b57aa10271a66f3dc936bba1d2f3830">state</a> = 0;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="main__adc_8c.html#a5a63998141f65a3976c1063796113c79">PORT_init</a> (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    PCC -&gt; PCCn[PCC_PORTC_INDEX] = PCC_PCCn_CGC_MASK;           <span class="comment">/* Enable clock for PORT C */</span></div><div class="line"></div><div class="line">    PORTC -&gt; PCR[<a class="code" href="main__adc__cal_8c.html#a604e2c12de518d39a1bd06956ab56a81">PTC6</a>] |= PORT_PCR_MUX(2);                      <span class="comment">/* Port C6: MUX = UART1 RX */</span></div><div class="line">    PORTC -&gt; PCR[<a class="code" href="main__adc__cal_8c.html#a5a314d89306f4b8d3a99c9ac3fb10ef5">PTC7</a>] |= PORT_PCR_MUX(2);                      <span class="comment">/* Port C7: MUX = UART1 TX */</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="main__adc__cal_8c.html#a6b69d83827359510ff3434b6547e53b0">Enable_Interrupt</a>(uint8_t vector_number)</div><div class="line">{</div><div class="line">    S32_NVIC-&gt;ISER[(uint32_t)(vector_number) &gt;&gt; 5U] = (uint32_t)(1U &lt;&lt; ((uint32_t)(vector_number) &amp; (uint32_t)0x1FU));</div><div class="line">    S32_NVIC-&gt;ICPR[(uint32_t)(vector_number) &gt;&gt; 5U] = (uint32_t)(1U &lt;&lt; ((uint32_t)(vector_number) &amp; (uint32_t)0x1FU));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="main__adc_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main</a> (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="clocks__and__modes_8c.html#a2f05a0e5aa290fba55984156198f14a2">SOSC_init_8MHz</a>();                       <span class="comment">/* Initialize system oscillator for 8 MHz xtal */</span></div><div class="line">    <a class="code" href="clocks__and__modes_8c.html#a5b337515ef6255432800f7793441527c">SPLL_init_160MHz</a>();                     <span class="comment">/* Initialize SPLL to 160 MHz with 8 MHz SOSC */</span></div><div class="line">    <a class="code" href="clocks__and__modes_8c.html#aa234261bbd2c76d65303e209757dc19b">NormalRUNmode_80MHz</a>();                  <span class="comment">/* Init clocks: 80 MHz sysclk &amp; core, 40 MHz bus, 20 MHz flash */</span></div><div class="line"></div><div class="line">    <a class="code" href="main__adc_8c.html#a5a63998141f65a3976c1063796113c79">PORT_init</a>();                            <span class="comment">/* Configure ports */</span></div><div class="line">    <a class="code" href="_l_p_u_a_r_t_8c.html#a735e25c9d923840ffb8b3f25e90f54c6">LPUART1_init</a>();                         <span class="comment">/* LPUART1 initialization */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Welcome message */</span></div><div class="line">    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;\r\n=============================================================================\r\n&quot;</span>);</div><div class="line">    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;This code interactively shows how the internal calibration of the ADC module\r\n&quot;</span>);</div><div class="line">    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;affects the reading of the result register (R). In addition to the internal\r\n&quot;</span>);</div><div class="line">    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;calibration, there is the possibility of modifying two registers for the Gain\r\n&quot;</span>);</div><div class="line">    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;(UG) and the Offset (USR_OFS) of the result by the user.\r\n\r\n&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Instructions */</span></div><div class="line">    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;Instructions:\r\n&quot;</span>);</div><div class="line">    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;   - Valid User Gain values are between 0 - 1023.\r\n&quot;</span>);</div><div class="line">    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;   - Valid User Offset values are between 0 - 255.\r\n&quot;</span>);</div><div class="line">    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;   - Offset and Gain values are in 2&#39;s-complement format.\r\n&quot;</span>);</div><div class="line">    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;   - There are negative and positive values. MSB determines the sign.\r\n&quot;</span>);</div><div class="line">    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;   - Press ENTER to send the Gain and Offset value. \r\n\r\n&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Ask for initial calibration */</span></div><div class="line">    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;Would you like to calibrate the ADC module? y/n.\r\n\r\n&quot;</span>);</div><div class="line">    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;&gt; &quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(;;)</div><div class="line">    {</div><div class="line">        <a class="code" href="main__adc__cal_8c.html#a1641e09b7d9068c3eefc78d79157047a">answer</a> = <a class="code" href="_l_p_u_a_r_t_8c.html#a556289ca43dede22a5d0426adfeffa81">LPUART1_receive_char</a>();                                    <span class="comment">/* Receive answer from the question above */</span></div><div class="line"></div><div class="line">        <span class="comment">/* ADC module with calibration */</span></div><div class="line">        <span class="keywordflow">if</span>(<a class="code" href="main__adc__cal_8c.html#a1641e09b7d9068c3eefc78d79157047a">answer</a> == <span class="charliteral">&#39;y&#39;</span>)</div><div class="line">        {</div><div class="line">            <a class="code" href="main__adc__cal_8c.html#a0b57aa10271a66f3dc936bba1d2f3830">state</a> = 1;</div><div class="line">            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;\r\n\r\n&quot;</span>);</div><div class="line">            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;ADC module calibration. Which Gain value would you like to set? \r\n\r\n&quot;</span>);</div><div class="line">            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;&gt; &quot;</span>);</div><div class="line"></div><div class="line">            <span class="keywordflow">while</span> (<a class="code" href="main__adc__cal_8c.html#a0b57aa10271a66f3dc936bba1d2f3830">state</a> == 1)</div><div class="line">            {</div><div class="line">                <a class="code" href="main__adc__cal_8c.html#a7c07aa50dffd011a3b181ea4ecb54f8e">gain</a> = <a class="code" href="_l_p_u_a_r_t_8c.html#a7203f5441ba24299d8565e7dd2d2ba46">LPUART1_receive_int</a>();                               <span class="comment">/* Receive Gain Value */</span></div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((<a class="code" href="main__adc__cal_8c.html#a7c07aa50dffd011a3b181ea4ecb54f8e">gain</a> &gt;= 0) &amp;&amp; (<a class="code" href="main__adc__cal_8c.html#a7c07aa50dffd011a3b181ea4ecb54f8e">gain</a> &lt;= 1023))                          <span class="comment">/* Gain Value validation */</span></div><div class="line">                {</div><div class="line">                    <a class="code" href="main__adc__cal_8c.html#a0b57aa10271a66f3dc936bba1d2f3830">state</a> = 2;</div><div class="line">                    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;ADC module calibration. Which Offset value would you like to set?\r\n\r\n&quot;</span>);</div><div class="line">                    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;&gt; &quot;</span>);</div><div class="line"></div><div class="line">                    <span class="keywordflow">while</span> (<a class="code" href="main__adc__cal_8c.html#a0b57aa10271a66f3dc936bba1d2f3830">state</a> == 2)</div><div class="line">                    {</div><div class="line">                        <a class="code" href="main__adc__cal_8c.html#ac681806181c80437cfab37335f62ff39">offset</a> = <a class="code" href="_l_p_u_a_r_t_8c.html#a7203f5441ba24299d8565e7dd2d2ba46">LPUART1_receive_int</a>();                     <span class="comment">/* Receive Offset Value */</span></div><div class="line"></div><div class="line">                        <span class="keywordflow">if</span> ((<a class="code" href="main__adc__cal_8c.html#ac681806181c80437cfab37335f62ff39">offset</a> &gt;= 0) &amp;&amp; (<a class="code" href="main__adc__cal_8c.html#ac681806181c80437cfab37335f62ff39">offset</a> &lt;= 255))               <span class="comment">/* Offset Value validation */</span></div><div class="line">                        {</div><div class="line">                            <a class="code" href="main__adc__cal_8c.html#a0b57aa10271a66f3dc936bba1d2f3830">state</a> = 0;</div><div class="line">                            <a class="code" href="_a_d_c_8c.html#ac27380c28d20b6c927922551d67cd743">ADC_calibration_init</a>(<a class="code" href="main__adc__cal_8c.html#a7c07aa50dffd011a3b181ea4ecb54f8e">gain</a>, <a class="code" href="main__adc__cal_8c.html#ac681806181c80437cfab37335f62ff39">offset</a>);             <span class="comment">/* Convert Channel AD12 to pot on EVB */</span></div><div class="line">                            <a class="code" href="_a_d_c_8c.html#af76221118c7f520fe574bd6845a07d90">ADC_channel_convert</a>(12);                        <span class="comment">/* Convert Channel AD12 to pot on EVB */</span></div><div class="line">                            <span class="keywordflow">while</span>(<a class="code" href="_a_d_c_8c.html#ac1e8aec564becbe003bfca11292ebd0e">ADC_conversion_complete</a>() == 0){}         <span class="comment">/* Wait for conversion complete flag */</span></div><div class="line">                            <a class="code" href="main__adc__cal_8c.html#a80c5f48bb6d79b957d2eaaf1f03b34bb">adc_mV_result</a> = <a class="code" href="_a_d_c_8c.html#ac3cde85577a5404fd5bc14cf3a06eb34">ADC_channel_read</a>();             <span class="comment">/* Get channel&#39;s conversion results in mV */</span></div><div class="line"></div><div class="line">                            <span class="comment">/* Send ADC result by UART */</span></div><div class="line">                            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;ADC result with calibration is: &quot;</span>);</div><div class="line">                            <a class="code" href="_l_p_u_a_r_t_8c.html#a2c21e01901e389a16d4a2f8eb9a0f282">LPUART1_int_to_char</a>(<a class="code" href="main__adc__cal_8c.html#a80c5f48bb6d79b957d2eaaf1f03b34bb">adc_mV_result</a>);             <span class="comment">/* Convert data from int to char to be able to send by UART */</span></div><div class="line">                            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot; mV with UG = &quot;</span>);</div><div class="line">                            <a class="code" href="_l_p_u_a_r_t_8c.html#a2c21e01901e389a16d4a2f8eb9a0f282">LPUART1_int_to_char</a>(<a class="code" href="main__adc__cal_8c.html#a7c07aa50dffd011a3b181ea4ecb54f8e">gain</a>);                      <span class="comment">/* Convert data from int to char to be able to send by UART */</span></div><div class="line">                            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot; and USR_OFS = &quot;</span>);</div><div class="line">                            <a class="code" href="_l_p_u_a_r_t_8c.html#a2c21e01901e389a16d4a2f8eb9a0f282">LPUART1_int_to_char</a>(<a class="code" href="main__adc__cal_8c.html#ac681806181c80437cfab37335f62ff39">offset</a>);                    <span class="comment">/* Convert data from int to char to be able to send by UART */</span></div><div class="line">                            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;\r\n\r\n&quot;</span>);</div><div class="line"></div><div class="line">                            <a class="code" href="_w_d_o_g_8c.html#ad769bce52edf5c9d1e8738e3ecac1d15">WDOG_init</a>();                                    <span class="comment">/* Reboot MCU to erase the ADC calibration register */</span></div><div class="line">                            <a class="code" href="main__adc__cal_8c.html#a6b69d83827359510ff3434b6547e53b0">Enable_Interrupt</a>(WDOG_EWM_IRQn);                <span class="comment">/* Enable WDOG interrupt vector */</span></div><div class="line">                        }</div><div class="line">                        <span class="keywordflow">else</span></div><div class="line">                        {</div><div class="line">                            <span class="comment">/* Incorrect answer. Invalid Offset Value */</span></div><div class="line">                            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;\r\n&quot;</span>);</div><div class="line">                            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;Incorrect Offset Value. Try again.\r\n\r\n&quot;</span>);</div><div class="line">                            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;&gt; &quot;</span>);</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                    <span class="comment">/* Incorrect answer. Invalid Gain Value */</span></div><div class="line">                    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;\r\n&quot;</span>);</div><div class="line">                    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;Incorrect Gain Value. Try again.\r\n\r\n&quot;</span>);</div><div class="line">                    <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;&gt; &quot;</span>);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* ADC module without calibration */</span></div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="main__adc__cal_8c.html#a1641e09b7d9068c3eefc78d79157047a">answer</a> == <span class="charliteral">&#39;n&#39;</span>)</div><div class="line">        {</div><div class="line">            <a class="code" href="_a_d_c_8c.html#a4b4a2ddcb45df0c8497c47d4ed800e2a">ADC_init</a>();                                         <span class="comment">/* ADC initialization without calibration */</span></div><div class="line">            <a class="code" href="_a_d_c_8c.html#af76221118c7f520fe574bd6845a07d90">ADC_channel_convert</a>(12);                            <span class="comment">/* Convert Channel AD12 to pot on EVB */</span></div><div class="line">            <span class="keywordflow">while</span>(<a class="code" href="_a_d_c_8c.html#ac1e8aec564becbe003bfca11292ebd0e">ADC_conversion_complete</a>() == 0){}             <span class="comment">/* Wait for conversion complete flag */</span></div><div class="line">            <a class="code" href="main__adc__cal_8c.html#a80c5f48bb6d79b957d2eaaf1f03b34bb">adc_mV_result</a> = <a class="code" href="_a_d_c_8c.html#ac3cde85577a5404fd5bc14cf3a06eb34">ADC_channel_read</a>();                 <span class="comment">/* Get channel&#39;s conversion results in mV */</span></div><div class="line"></div><div class="line">            <span class="comment">/* Send ADC result by UART */</span></div><div class="line">            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;\r\n\r\n&quot;</span>);</div><div class="line">            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;ADC result without calibration is: &quot;</span>);</div><div class="line">            <a class="code" href="_l_p_u_a_r_t_8c.html#a2c21e01901e389a16d4a2f8eb9a0f282">LPUART1_int_to_char</a>(<a class="code" href="main__adc__cal_8c.html#a80c5f48bb6d79b957d2eaaf1f03b34bb">adc_mV_result</a>);                 <span class="comment">/* Convert data from int to char to be able to send by UART */</span></div><div class="line">            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot; mV\r\n\r\n&quot;</span>);</div><div class="line"></div><div class="line">            <a class="code" href="_w_d_o_g_8c.html#ad769bce52edf5c9d1e8738e3ecac1d15">WDOG_init</a>();                                        <span class="comment">/* Reboot MCU to erase the ADC calibration register */</span></div><div class="line">            <a class="code" href="main__adc__cal_8c.html#a6b69d83827359510ff3434b6547e53b0">Enable_Interrupt</a>(WDOG_EWM_IRQn);    <span class="comment">/* Enable WDOG interrupt vector */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Incorrect answer. Input different of y/n */</span></div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;\r\n\r\n&quot;</span>);</div><div class="line">            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;Incorrect input. Try again.\r\n\r\n&quot;</span>);</div><div class="line">            <a class="code" href="_l_p_u_a_r_t_8c.html#a13bfec91c1a423ccb71fcfed397c25d1">LPUART1_transmit_string</a>(<span class="stringliteral">&quot;&gt; &quot;</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="ewm_8c.html#a3412c1de21dec198a4c2f13ee4416157">WDOG_EWM_IRQHandler</a> (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* WDOG interrupt flag active */</span></div><div class="line">    <span class="keywordflow">if</span>((WDOG -&gt; CS &amp; WDOG_CS_FLG_MASK) == WDOG_CS_FLG_MASK)</div><div class="line">    {</div><div class="line">        WDOG -&gt; CS |= WDOG_CS_FLG_MASK;                                 <span class="comment">/* Clear the flag */</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
